<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<script type="text/javascript" src="https://code.jquery.com/jquery-3.2.1.min.js"></script>

	<script type="text/javascript" src="https://rawgit.com/jgraph/mxgraph/master/javascript/mxClient.js"></script>
	<script type="text/javascript" src="https://rawgit.com/vkiryukhin/vkBeautify/master/vkbeautify.js"></script>

	<!-- Materialize color picker plugin -->
	<link type="text/css" rel="stylesheet" href="css/materialize-colorpicker.min.css"/>

	  <!--Import Google Icon Font-->
      <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
      <!--Import materialize.css-->
      <link type="text/css" rel="stylesheet" href="css/materialize.min.css"  media="screen,projection"/>

      <!--Let browser know website is optimized for mobile-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	
	<style type="text/css">
	body
	{
		background-color:#FFFFFF;width:100%;
	}
	#editorContainer
	{
		width:450px;
		background-color:rgb(230, 227, 227);
		position:fixed;
		top:50px;
		height: calc(100% - 50px);
		display: table-cell;
		left: 0;
	}
	#editorContainer_container_tabContent
	{
		position: relative;
		width: calc(100% - 50px);
		height: 100%;
		float:right;
	}
	.editorContainer_container_tab
	{
		position:relative;
		width: calc(100% - 50px);
		height: 100%;
		float: right;
		display:none;
		background-color: white;
	}
	#editorContainer_tabsContainer
	{
		position:relative;
		width: 50px;
		height:100%;
		float:left;
		border: none;
		background-color: #2b303b;
	}
	.editor_tabs_button, .editor_tabs_button_active
	{
		width:80%;
		margin: 10%;
		position: relative;
		height: 45px;
		background-color: #2b303b;
		border: none;
		color: white;
	}
	.editor_tabs_button:hover
	{
		background-color: #941818;
	}
	.editor_tabs_button_active
	{
		background-color: #c91e1e;
	}
	.editor_tabs_button_active:focus
	{
		background-color: #c91e1e;
	}
	#editor
	{
		width: 100%;
		height: 150px;
	}

	#div_editor_nodeContentContainer
	{
		width: 100%;
		height: 100%;
		top: 0;
	}
	#graphContainer
	{
		height:95%;
		width: 1086px;
		float:left;
		background-color:#2b303b;
		cursor: default;
		position: fixed;
		top: 50px;
		left: 450px;
		overflow-y: scroll;
	}

	.button_header_actionBar
	{
		width:25px;
		height:25px;
	}

	#init_overlay
	{
		display: none;
		position: fixed;
		left: 20%;
		width: 60%;
		top: 20%;
		height: 60%;
		background: #FFF;
		z-index: 20;
	}
	#mask
	{
		position:fixed;
		top:0;
		left:0;
		background:rgba(0,0,0,0.6);
		z-index:10;
		width:100%;
		height:100%;
		display:none;
	}	
	#init_overlay:target, #init_overlay:target + #mask
	{
		display:block;
		opacity:1;
	}
	.close
	{ 
		display:block;
		position:absolute;
		top:-20px;
		right:-20px;
		background:red;
		color:white;
		height:40px;
		width:40px;
		line-height:40px;
		font-size:35px;
		text-decoration:none;
		text-align:center;
		font-weight:bold;
		border-radius:40px;
	}
	#a_showOverlay
	{
		display:none;
	}
	#div_overlay_main
	{
		width:100%;
		height:80%;
		position:relative;
		top:0;
		left:0;
		background-color: #FFFFFF;
	}
	#div_overlay_main_newMap
	{
		background-color: #2b303b;
		position:relative;
		float:left;
		left:5%;
		width:40%;
		height:80%;
		top:10%;
		border-radius: 2px;
	}
	#div_overlay_main_newMap:hover{
		border: 1px red;
	}
	#div_overlay_main_newMap p
	{
		margin:0;
		position:absolute;
		top:50%;
		left:50%;
		transform: translate(-50%, -50%);
	}
	#div_overlay_main_loadMap
	{
		background-color: #2b303b;
		position:relative;
		float:right;
		right:5%;
		width:40%;
		height:80%;
		top:10%;
		border-radius:2px;
	}
	#div_overlay_main_loadMap p
	{
		margin:0;
		position:absolute;
		top:50%;
		left:50%;
		transform: translate(-50%, -50%);
	}
	#button_overlay_loadMap
	{
		position:absolute;
		bottom:0;
		left:30%;
		width:40%;
		display:none;
	}
	#div_overlay_bottom
	{
		background-color: #FFFFFF;
		width:100%;
		height:20%;
		position:relative;
	}
	#button_overlay_bottom_confirm
	{
		width:40%;
		height:50%;
		position:absolute;
		top:25%;
		left:30%;
	}
	#speakerTab_speakersList
	{
		list-style-type: none;
		padding: 0;	
	}

	.collection-item
	{
		height: 25px;
	}


	/* Editor Content Tab */
	.button_editorContent_formatText
	{
		width:30%;
		padding: 0px;
		margin-bottom: 10px;
		position: relative;
		left: 6px;

	}
	.button_editorContent_formatText:hover
	{
		background-color: #888888
	}
	#div_container_speakersList
	{
		position: relative;
		width: 96%;
		left: 2%;
		padding: 0;
	}
	#div_container_speakersList ul
	{
		overflow: hidden;
		overflow-y: scroll;	
		max-height: 337px;
	}
	/* The button "File" to select a logo for the speaker */
	#editor_inputFile_buttonDiv
	{
		height: 35px;
		line-height: 35px;
	}
	#editor_inputFile_textDiv
	{
		height: 32px;
		line-height: 35px;
	}
	#editor_inputFile_containerDiv
	{
		margin-bottom: 10px;
		width: 100%;
	}
	#button_editor_newSpeaker
	{
		position: relative;
		left: calc(50% - 28px);
		background-color: #01579B;
	}
	#button_editor_newSpeaker:hover
	{
		background-color: #a0a0a0;
	}
	#button_editor_unload
	{
		position: relative;
		left: calc(50% + 10px);
		height: 24px;
		width: 24px;
   		line-height: 24px;
   	    padding: 0 0.5rem;
		background-color: #01579B;
		display: none;
	}
	#editor_inputName_containerDiv
	{
		position: relative;
		width: 96%;
		left: 2%;
	}
	#editor_form_divContainer
	{
		position: relative;
		width: 96%;
		left: 2%
	}
	#editorContent_textArea_divContainer
	{
		position: relative;
		width: 96%;
		left: 2%;
		padding: 0;
		height: 415px;
		max-height: 415px;
	}
	#editorContent_form_divContainer
	{
		position: relative;
		width: 96%;
		left: 2%;
	}

	#textarea_editor_nodeContent
	{
		position: relative;
		display: inline-block;
		width: 100%;
		height: 415px;
		max-height: 415x;
		overflow-y: scroll;
		resize: none;
		padding: 0;
	}
	#button_editor_addSaveNode
	{
		position: relative;
		width: 100%;
		display: inline-block;
		top: -22px;
	}	
	#button_editor_addSaveNode:hover
	{
		background-color: #a0a0a0;
	}	
	#button_editor_deleteNode
	{
		position: relative;
		width: 20%;
		float: right;
		top: 200px;
	}
	#editorMetadata_updateButton
	{
		position: relative;
		width: 100%;
		display: none;
	}
	#editorMetadata_updateButton:hover
	{
		background-color: #a0a0a0;
	}
	#editorMetadata_containerDiv
	{
		position: relative;
		width: 96%;
		left: 2%;		
	}
	#editorMetadata_globalContainerDiv
	{
		position: relative;
		width: 96%;
		left: 2%;		
	}
	#editorDev_devDiv	
	{
		position: relative;
		width: 96%;
		left: 2%;		
	}
	#header 
	{
		width:100%;
		height:50px;
		position: fixed;
		top:0;
		left:0;
		background-color:#3D4752;
	}
	#header_list
	{
		position: absolute;
		display: inline;
		list-style-type: none;
		padding-right: 20px;
		right: 0;
		top: -10px;
		color: white;
	}
	#header_list li
	{
		float: left;
		padding: 10px;
	}
	#header_title
	{
		color: white;
		font-family: "entangled";
		font-variant: small-caps;
		position: relative;
		left : 50px;
		top: -10px;
		font-size: large;
	}
	.overlay_text
	{
		font-family: "entangled";
		font-variant: small-caps;
		font-size: large;
		color: white;
	}
	#editor_colorPicker_divContainer
	{
		display: inline-block;
		border-radius: 10px;
		background-color: black;
	}
	#editorSpeaker_colorPicker
	{
		width: 50;
		height: 50;
		border-radius: 15px;
	}
	.speakerList-colorViewer
	{
		width: 30px;
		height: 30px;
		position: absolute;
		display: inline-block;
		right: 35px;
		top: 25px;
		border-radius: 10px;
	}
	</style>
</head>
<body  >

	<!-- Create a container for the overlay of the the mask behind it -->
	<div id="init_overlay">
		<div id="div_overlay_main">
			<div id="div_overlay_main_newMap">
				<p class="overlay_text">New Map</p>
			</div>
			<div id="div_overlay_main_loadMap">
				<p class="overlay_text">Import Map</p>
				<input type="file" id="button_overlay_loadMap">
			</div>
		</div>
		<div id="div_overlay_bottom">
			<input type="button" id="button_overlay_bottom_confirm" value="Confirm" class="btn light-blue darken-4">
		</div>
	</div>
	<div id="mask"></div>

	<!-- Create a div container for the header -->
	<div id="header">
			<a href="#init_overlay" id="a_showOverlay">Open Overlay</a>	
			<p id="header_title" >SpeechMap</p>
			<ul id="header_list">
				<li>Documentation</li>
				<li>Contact</li>
			</ul>

	</div>
	
	<!-- Create a container for the editor -->
	<div id="editorContainer">
		<div id="editorContainer_tabsContainer">
			<button id="editorContainer_tabsContainer_content" class="editor_tabs_button">C</button>
			<button id="editorContainer_tabsContainer_speaker" class="editor_tabs_button">S</button>
			<button id="editorContainer_tabsContainer_metadata" class="editor_tabs_button">M</button>
			<button id="editorContainer_tabsContainer_dev" class="editor_tabs_button">Dev</button>
		</div>
		<!-- Content tab -->
		<div id="editorContainer_container_tabContent" class="editorContainer_container_tab">
			<div id="editor">
				<div class="card-panel" id="editorContent_form_divContainer">
					<input type="button" id="button_editorContent_bold" class="btn button_editorContent_formatText" value="B">
					<input type="button" id="button_editorContent_italic" class="btn button_editorContent_formatText" value="I">
					<input type="button" id="button_editorContent_underligned" class="btn button_editorContent_formatText" value="U">
					<div class="mui-divider"></div>
					<br>
					<div class="input-field">
						<select id="select_editor_speaker">
						</select>
						<label>Choose Speaker</label>
					</div>
					<form id="form_editor_side">
						<input type="radio" id="radio_editor_left" name="side" value="Left" checked=true>
						<label for="radio_editor_left">Left</label>
						
						<input type="radio" id="radio_editor_right" name="side" value="Right" checked=true>
						<label for="radio_editor_right">Right</label>
					</form>
				</div>
				<div class="card-panel" id="editorContent_textArea_divContainer">
					<div class="input-field col s12">
						<textarea id="textarea_editor_nodeContent" type="text" class="materialize-textarea"></textarea>
						<label for="textarea_editor_nodeContent">Node content</label>
					</div>
					<button id="button_editor_addSaveNode" value="Add node" class="btn light-blue darken-4">
						Add Node
					</button>
					<a class="btn tooltipped light-blue darken-4" data-position="right" data-delay="50" 
						data-tooltip="Delete the selected node" id="button_editor_deleteNode">
					<i class="material-icons">delete</i>
					</a>
				</div>
			</div>
		</div>
		<!-- Speaker tab -->
		<div id="editorContainer_container_tabSpeaker" class="editorContainer_container_tab">
			<div class="card-panel" id="editor_form_divContainer">
				<div class="input-field col s12" id="editor_inputName_containerDiv">
					<input id="input_editor_newSpeaker" type="email" class="validate">
					<label for="input_editor_newSpeaker">Speaker name</label>
				</div>
				<div id="editorSpeaker_colorPicker" class="file-field">
					<div class="btn"></div>
					<div class="file-path-wrapper">
					  <input type="text" />
					</div>
				</div>				<div class="file-field input-field" id="editor_inputFile_containerDiv">
					<div class="btn" id="editor_inputFile_buttonDiv">
						<span>File</span>
						<input type="file">
					</div>
					<div class="file-path-wrapper" id="editor_inputFile_textDiv">
						<input class="file-path validate" type="text"  placeholder="Select speaker logo" disabled>
					</div>
				</div>
				<a class="btn-floating btn-large tooltipped" data-position="right" data-delay="50" 
					data-tooltip="Register a new speaker" id="button_editor_newSpeaker">
					<i class="material-icons">add</i>
				</a>
				<a class="btn-floating btn-tiny tooltipped" data-position="right" data-delay="50" 
					data-tooltip="Unselect the speaker" id="button_editor_unload">
					<i class="material-icons" style="font-size:1em; position: relative;	top: -8px;	left: -7px;" id="button_editor_unloadIcon">clear</i>
				</a>
			</div>
			<div id="div_container_speakersList" class="card-panel">
				<ul class="collection" id="speakerTab_speakersList">
				</ul>
			</div>
		</div>
		<!-- Metadata tab -->
		<div id="editorContainer_container_tabMetadata" class="editorContainer_container_tab">
			<div class="card-panel" id="editorMetadata_globalContainerDiv">
				Select whether information is global or specific to each node
				<br>
				<!-- Switch -->
				<div class="switch">
					<label>
					Local
					<input type="checkbox" id="editorMetadata_isGlobalCheckbox" checked>
					<span class="lever"></span>
					Global
					</label>
				</div>
			</div>
			<div class="card-panel" id="editorMetadata_containerDiv">			
				<!-- Location input field -->
				<div class="input-field col s6">
					<i class="material-icons prefix">location_on</i>
					<input id="editorMetadata_locationInput" type="text" class="validate">
					<label for="editorMetadata_locationInput">Location</label>
				</div>
				<!-- Date picker (requires js init code) -->
				<div class="input-field col s6">
					<i class="material-icons prefix">date_range</i>
					<input type="text" class="datepicker" id="editorMetadata_datepicker">
					<label for="editorMetadata_datepicker">Date</label>
				</div>
				<button id="editorMetadata_updateButton" value="Update" class="btn light-blue darken-4">
					Update
				</button>
			</div>
		</div>
		<!-- Dev tab -->
		<div id="editorContainer_container_tabDev" class="editorContainer_container_tab">
			<div class="card-panel" id="editorDev_devDiv">
				<input type="button" id="button_addNode_HerrA" value="Add Node Herr A">
				<input type="button" id="button_addNode_HerrB" value="Add Node Herr B">
			
				<input type="button" id="button_clear" value="Clear">
				<input type="button" id="button_xmlString" value="XML String">	
			</div>
		</div>
	</div>



	<!-- Creates a container for the graph with a grid wallpaper -->
	<div id="graphContainer">
	</div>
<script>
//SpeechMap library

// TODOList

// TODO -- Remove node
// TODO -- Add the 'active' class to the labels when loading a value in the editor
// TODO -- Fix the ":hover" css class for the buttons in the Metadata tab
// TODO -- Add or update all the tooltips for the button

// PROJECT ARCHITECTURE
// TDOD -- Split the "index.html" file into three separate files: html, css and javascript
// TODO -- Rework the names and establish new naming conventions for id and class

//	GRAPHICS
/**
 * NodeCategoryEnum Enum. Defines the different types of Node that can exist.
 */
function Speaker(speakerName, color)
{
	this.name = speakerName;
	this.color = color;
}


var NodeCategoryEnum = {
		DEFAULT: 0,
		START: 1,
		END: 2,
};

/*************************************************************************************
 *	Node_Metadata Class
 *	Contains all the metadata about a specific Node(or vertex) of the map.
 *************************************************************************************/
function Node_Metadata(speakerName, side, location, date)
{
	this.speakerName = speakerName;
	this.side = side;
	this.location = location;
	this.date = date; 
}

/*************************************************************************************
 *	Node Class
 *	Contains all the data about a specific vertex (or node) of the map.
 *************************************************************************************/
function Node(category, content)
{
	this.category = category;
	this.content = content;
	this.isLabelTruncated = false;
	this.vertex = null;
	this.vertex_treeNode = null;
	this.vertex_extender = null;
	this.vertex_extension = null;
	this.edgesList = [];
	this.metadata = null;
	this.id = generateId();
};

Node.prototype.getSide = function() {
	return this.metadata.side;
}

/*************************************************************************************
 *	SpeechMap_Metadata Class
 *	Contains all the Metadata of one SpeechMap
 *************************************************************************************/
 
 /**
  * Constructor. Create the list of registered speakers that will be filled by SpeechMap or other entities.
  */
function SpeechMap_Metadata() {
	this.speakersList = [];
	this.location = null;
	this.date = null;
}

/*************************************************************************************
 *	SpeechMap Class 
 *	This is the base class of the Application. 
 *************************************************************************************/
 
/**
 * Constructor. This will create the Map (model, controller and it's renderer/view)
 * @param XMLDocument xmlDoc Value null means that the default map will be created, otherwise the map is created based on the data in the xml document.
 */
function SpeechMap(xmlDoc){	

	// Static variables
	/* Booleans stored in the SpeechMap object */
	this.nodeSelected_b = false;

	/* Boolean to determine whether the Node metadata (date, location) should be store globally or locally for each node */
	this.isNodeMetaGlobal_b = null;

	if (xmlDoc == null) {
		console.log("Creating the default map");
		this.metadata = new SpeechMap_Metadata();
		
		this.nodesNumber = 2; // Start node and End node
		this.nodesList = [this.nodesNumber];
		
		// Create the Start node
		this.nodesList[0] = new Node(NodeCategoryEnum.START, null);
		this.nodesList[1] = new Node(NodeCategoryEnum.END, null);
	} else { // Meaning (xmlDoc != null)
		/* Build the metadata stuff for the SpeechMap */
		this.metadata = new SpeechMap_Metadata;
		var sm_node = xmlDoc.getElementsByTagName("SpeechMap")[0];
		var sm_metadata = sm_node.getElementsByTagName("metadata")[0];
		// Build the list of speakers
		var speaker_nodeList = [].slice.call(sm_metadata.getElementsByTagName("speaker"));
		for ( var i in speaker_nodeList) {
			var name = speaker_nodeList[i].firstChild.nodeValue.trim();
			var color = speaker_nodeList[i].getAttribute("color");
			console.log("Detected speaker entity :" + name + " and color " + color);
			this.metadata.speakersList.push(new Speaker(name, color));
		}
		// Build the date and location 
		var isNodeMetaGlobal_b_str = sm_metadata.getElementsByTagName("isNodeMetaGlobal_b")[0].firstChild.nodeValue.trim();

		if (isNodeMetaGlobal_b_str == "true"){
			this.isNodeMetaGlobal_b = true;
		} else {
			this.isNodeMetaGlobal_b = false;
		}

		// Set the node and date globally if enabled. 
		if (this.isNodeMetaGlobal_b == true){
			this.metadata.location = sm_metadata.getElementsByTagName("location")[0].firstChild.nodeValue.trim();
			this.metadata.date = sm_metadata.getElementsByTagName("date")[0].firstChild.nodeValue.trim();

			// The values should be loaded in the editor aswell
			// This is done in the post-init phase
		}

		this.nodesNumber = xmlDoc.getElementsByTagName("node").length;
		this.nodesList = [this.nodesNumber];		
		
		// Loop over the content nodes to create the node model
		for (var i = 0; i < this.nodesNumber; i++){
			var node =  xmlDoc.getElementsByTagName("node")[i];
			var content = node.getElementsByTagName("content")[0].firstChild;
			
			// Determine the category for the current node
			var nodeCategory = null;
			if (node.attributes[0].nodeValue === "start"){
				nodeCategory = NodeCategoryEnum.START;
			}else if ( node.attributes[0].nodeValue === "end"){
				nodeCategory = NodeCategoryEnum.END;
			}else{
				nodeCategory = NodeCategoryEnum.DEFAULT;
			}
			
			// Create Node objects
			if (content){
				this.nodesList[i] = new Node(nodeCategory, content.nodeValue.trim());
			}else{
				// If no content, set value to null
				this.nodesList[i] = new Node(nodeCategory, null);
			}
			
			/* Fill the metadata for the current Node */
			var metadata = node.getElementsByTagName("metadata")[0];
			var nodeSide = metadata.getAttribute("side");
			var speakerName = metadata.getAttribute("speakerName");
			// Default values for location and date in case they are not needed for each node
			var location = null;
			var date = null;

			if (this.isNodeMetaGlobal_b == false){
				location = metadata.getAttribute("location");
				date = metadata.getAttribute("date");
			}

			if (speakerName && nodeSide){
				this.nodesList[i].metadata = new Node_Metadata(speakerName, nodeSide, location, date);
			} 
		}
	}
	
	/* Instanciate a SpeechMap_Editor class */
	this.editor = new SpeechMap_Editor(this.metadata.speakersList, this.metadata.location, this.metadata.date);
	
	/* Instanciate a SpeechMap_GraphController class */
	this.graphController = new SpeechMap_GraphController();
	
	/* Instanciate a SpeechMap_Renderer class */
	this.renderer = new SpeechMap_Renderer();


	// A post-init sequence will be called once the sm global object is built
};

// Function to execute the Post-Initialisation sequence
// This is required since the function here need a fully built global SpeechMap object
SpeechMap.prototype.executePostInitSequence = function() {
	// Request the Metadata mode (either Global or Local)
	this.editor.requestMetadataMode(this.isNodeMetaGlobal_b);
}
	
// Function serializeToConsole
SpeechMap.prototype.serializeToConsole = function(){
	var retString = "BeginMap\n";
	
	var indentLevel = 1;
	for (var i in this.nodesList){
		var node = this.nodesList[i];
		
		if (node.content){
			retString += "\t".repeat(indentLevel) + node.content + "\n";
			
			if (node.content === "start"){
				indentLevel += 1;
			}else if (node.content === "end"){
				indentLevel -= 1;
			}
		}
	}
	
	retString += "EndMap";
	
	return retString;
};

// Function serializeToXML

SpeechMap.prototype.serializeToXML = function() {
	var xmlString = "<SpeechMap></SpeechMap>"
	
	var parser = new DOMParser();
	var xmlDoc = parser.parseFromString(xmlString, "text/xml");
	var rootNode = xmlDoc.getElementsByTagName("SpeechMap")[0];
	
	var metaNode = xmlDoc.createElement("metadata");
	// Add the <speaker> tags 
	for (var i in this.metadata.speakersList) {
		var currentSpeaker = this.metadata.speakersList[i];
		var speaker_node = xmlDoc.createElement("speaker");
		speaker_node.appendChild(xmlDoc.createTextNode(currentSpeaker.name));
		speaker_node.setAttribute("color", currentSpeaker.color);
		metaNode.appendChild(speaker_node);
	}

	// Add the "isNodeMetaGlobal_b" boolean value to the export (for import compatibility)
	var value_node = xmlDoc.createElement("isNodeMetaGlobal_b");
	value_node.appendChild(xmlDoc.createTextNode(this.isNodeMetaGlobal_b));
	metaNode.appendChild(value_node);

	// If the Node Metadata is global, write it in the sm metadata. Else it will be written for each node
	if (this.isNodeMetaGlobal_b == true){	
		// Add the <location> and <date> tags
		var date = this.metadata.date;
		var date_node = xmlDoc.createElement("date");
		date_node.appendChild(xmlDoc.createTextNode(date));
		metaNode.appendChild(date_node);

		var location = this.metadata.location;
		var location_node = xmlDoc.createElement("location");
		location_node.appendChild(xmlDoc.createTextNode(location));
		metaNode.appendChild(location_node);
	}

	rootNode.appendChild(metaNode);
		
	for (var i in this.nodesList){
		var node = this.nodesList[i];
				
		var tmpNode = xmlDoc.createElement("node");
		
		// Set the node category attribute
		var categoryString = "";
		if (node.category === NodeCategoryEnum.DEFAULT){
			categoryString = "default";
		}else if (node.category === NodeCategoryEnum.START){
			categoryString = "start";
		}else if (node.category === NodeCategoryEnum.END){
			categoryString = "end";
		}
		tmpNode.setAttribute("category", categoryString);

		// Create the node content and metadata nodes
			var metaNode = xmlDoc.createElement("metadata");
			if (node.metadata){
				metaNode.setAttribute("speakerName", node.metadata.speakerName);
				metaNode.setAttribute("side", node.metadata.side);

				// Store the date on each node if the option has been enabled
				if (this.isNodeMetaGlobal_b == false){
					metaNode.setAttribute("date", this.metadata.date);
					metaNode.setAttribute("location", this.metadata.location);
				}
			}
			tmpNode.appendChild(metaNode);
		
			var contentNode = xmlDoc.createElement("content");
			if(node.content){
				contentNode.appendChild(xmlDoc.createTextNode(node.content));
			}
			tmpNode.appendChild(contentNode);
		
		rootNode.appendChild(tmpNode);
	}
	
	var serializer = new XMLSerializer();
	xmlString = serializer.serializeToString(xmlDoc);
	console.log(xmlString);
	
	console.log(vkbeautify.xml(xmlString));
	

		
	//this.saveContentToFile(vkbeautify.xml(xmlString));
}

SpeechMap.prototype.saveContentToFile = function(content) {
	var textAsBlob = new Blob([content], {type: "text/plain"});
	var link = document.createElement("a");
	link.download = "SpeechMap.xml";
	link.innerHTML = "Download file";
	link.href = window.URL.createObjectURL(textAsBlob);
	document.body.appendChild(link);
	link.click();
	link.outerHTML = "";
}
	
SpeechMap.prototype.makeGraph = function(graph, parent){

	var graphDiv = document.getElementById("graphContainer");
	var scrollValue = graphDiv.scrollTop;
	// Make the renderer object render the graph based on the current nodes and metadata.
	this.renderer.render(graph, parent, this.nodesList, this.metadata);	
	
	// Adjust the view of the graph
	this.graphController.scrollGraph(scrollValue);
};

SpeechMap.prototype.addNode = function (category, content, speakerName, side){

	// Move the "end" node at the end of the list
	var endNode  = this.nodesList.pop();

	this.nodesList.push(new Node(category, content.trim()));
	this.nodesList[this.nodesList.length - 1].metadata = new Node_Metadata(speakerName, side);
	
	this.nodesList.push(endNode);
};


SpeechMap.prototype.clearMap = function(graph){
	graph.getModel().beginUpdate();
	graph.removeCells(graph.getModel().getChildVertices(parent));
	graph.getModel().endUpdate();
}

SpeechMap.prototype.isContentVertex = function(cell) {
	var retBool = false;
	
	for (var i in this.nodesList){
		var node = this.nodesList[i];
		if (node.vertex === cell)
		{
			if (node.category === NodeCategoryEnum.DEFAULT)
			{			
				retBool = true;
				break;
			}
		}
	}
	
	return retBool;
}

SpeechMap.prototype.isMetaVertex = function(cell) {
	var retBool = false;
	
	for (var i in this.nodesList){
		var node = this.nodesList[i];
		if (node.vertex_treeNode === cell)
		{		
			retBool = true;
			break;
		}
	}
	
	return retBool;
}

SpeechMap.prototype.isVertexLabelTruncated = function(cell) {
	var retBool = false;

	for (var i in this.nodesList)
	{
		var node = this.nodesList[i];
		if (node.vertex === cell)
		{
			if (node.isLabelTruncated === true)
			{
				retBool = true;
				break;
			}
		}
	}
	
	return retBool;
}

// TODO There are two returns here..
SpeechMap.prototype.getMatchingNode = function(cell) {
	for (var i in this.nodesList)
	{
		if (this.nodesList[i].vertex === cell)
		{
			return this.nodesList[i];
		}
	}
	
	return null;
}

SpeechMap.prototype.isCellVertexExtender = function(cell) {
	var retval_b = false;

	for (var i in this.nodesList)
	{
		if (this.nodesList[i].vertex_extender === cell)
		{
			retval_b =  true
			break;
		}
	}
	
	return retval_b;
}

SpeechMap.prototype.isCellVertexExtension = function(cell) {
	var retval_b = false;
	
	for (var i in this.nodesList) {
		if (this.nodesList[i].vertex_extension === cell){
			retval_b = true;
			break;
		}
	}
	
	return retval_b;
}

SpeechMap.prototype.getNodeFromVertexExtender = function(cell) {
	var retval = null;
	for (var i in this.nodesList)
	{
		if (this.nodesList[i].vertex_extender === cell)
		{
			retval =  this.nodesList[i];
			break;
		}
	}
	
	return retval;
}

SpeechMap.prototype.getNodeFromVertexExtension = function(cell) {
	var retval = null;
	
	for (var i in this.nodesList) {
		if (this.nodesList[i].vertex_extension === cell) {
			retval = this.nodesList[i];
			break;
		}
	}
	
	return retval;
}

SpeechMap.prototype.setNodeSelected = function(selectedNode) {
	this.nodeSelected_b = true;
	this.currentSelectedNode = selectedNode;
	
	// Change the text of the Editor button from Add to Update
	$("#button_editor_addSaveNode")[0].innerHTML = "Update Node";
	$("#button_editor_addSaveNode")[0].style.width = "78%";

	// Add the "Delete node" button
	$("#button_editor_deleteNode")[0].style.top = "-22px";

	// If the Node Metadata is set for each node
	if (this.isNodeMetaGlobal_b == false){
		// Load the node metadata (date / location) in the Metadata tab. This will also make the visual effects appear
		this.editor.loadMetadata(selectedNode.metadata.location, selectedNode.metadata.date);
	}
}

SpeechMap.prototype.unsetNodeSelected = function() {
	this.nodeSelected_b = false;
	this.editor.clearTextArea();
	$("#button_editor_addSaveNode")[0].innerHTML = "Add Node";

	// Remove the "Delete node" button
	$("#button_editor_deleteNode")[0].style.top = "200px";
	$("#button_editor_addSaveNode")[0].style.width = "100%";

	// If the Node Metadata is set for each node
	if (this.isNodeMetaGlobal_b == false){
		// Unload the node metadata (date/location) in the metadata tab. Also hides the visual effects
		this.editor.unloadMetadata();
	}
}

SpeechMap.prototype.getNodeSelected = function() {
	return this.currentSelectedNode;
}

SpeechMap.prototype.isNodeSelected = function() {
	return this.nodeSelected_b;
}

SpeechMap.prototype.getColorFromSpeakerName = function(speakerName){
	for(var i = 0; i <  this.metadata.speakersList.length; i++){
		var speaker = this.metadata.speakersList[i];
		if(speaker.name == speakerName){
			return speaker.color;
		}
	}
	return "#ffffff"; // White is default color
}

SpeechMap.prototype.deleteNode = function(nodeId) {
	console.log("DEBUG -- Delete request for the following id" + nodeId);

	for (var i = 0; i < this.nodesList.length; i++) {
		if (this.nodesList[i].id == nodeId) {
			console.log("Found a match at index "+ i);
			this.nodesList.splice(i, 1);
			this.nodesNumber--;

			console.log(this.nodesNumber);
			console.log(this.nodesList);
			this.makeGraph(graph, parent);
		}
	}
}


/*************************************************************************************
 *	SpeechMap_Editor Class 
 *	Contains all the Javascript related to the editor on the left side of the page
 *************************************************************************************/
 
 /**
  * Constructor. Will register callback functions for the editor's html elements. Will also add to the editor the registered speakers from the loaded map
  * @param IN StringList speakerList The list of regsitered speakers from the loaded map. Can be empty. Names will be strings.
  * @param IN String location The location associated to the SpeechMap.
  * @param IN StringList date The date associated to the SpeechMap.
  */
 SpeechMap_Editor = function (speakersList, location, date) {
	console.log("SpeechmapEditorConstructor");

	// Class variable. Is true when one speaker is selected from the list, false otherwise
	this.selectedSpeakerName = null;
	this.speakerIsSelected = false;
	
	// Add the registered speakers from the loader map to the editor
	if (speakersList) {
		for (var i in speakersList) {
			var name = speakersList[i].name;
			var select = $("#select_editor_speaker")[0];
			var new_option = document.createElement("option");
			new_option.value = name;
			new_option.innerHTML = name;
			select.appendChild(new_option);
			$('#select_editor_speaker').material_select();

			// Get the color for the speaker
			var color = speakersList[i].color;

			// DEBUG -- Add logo here
			this.addSpeakerInList(name, "logo", color);
		}
	}

	// Add the location and the date to the Metadata tab of the Editor
	if (location) {
		$("#editorMetadata_locationInput")[0].value = location;
	}
	if(date){
		$("#editorMetadata_datepicker")[0].value = date;
	}
	
	// Add onclick callback to the "Register New Speaker" of the Editor
	$("#button_editor_newSpeaker").click(function(){
		console.log("Button New Speaker");
		var input_field = document.getElementById("input_editor_newSpeaker");
		var value = input_field.value;
		if (value !== ""){
			var select = document.getElementById("select_editor_speaker");
			var new_option = document.createElement("option");
			new_option.value = input_field.value;
			new_option.innerHTML = input_field.value;
			select.appendChild(new_option);
			// Code specific to Materialize css when updating select
			$('#select_editor_speaker').material_select();
			
			// Retrieve the color for this speaker
			var color = $("#editorSpeaker_colorPicker").data('colorpicker').color.toHex();
			
			// TODO -- Here we should add the logo

			if (sm.editor.speakerIsSelected == false) {

				// Add the new Speaker to the view
				sm.editor.addSpeakerInList(value, "logo", color);
				// Add the new Speaker to the model
				sm.metadata.speakersList.push(new Speaker(value, color));
			
			} else {
				sm.editor.updateSelectedSpeaker(value, "logo", color);
			}
		}

		input_field.value = "";
	});

	// Add callback to the "Add/Save" button of the Editor
	$("#button_editor_addSaveNode").click(function(){
		var input_field = document.getElementById("textarea_editor_nodeContent");
		var value = input_field.value;
		
		// If no Node is currently selected, the button functionality is to "Add" a node
		if (sm.isNodeSelected() === false) {
			if (value !== "") {
				var radio_sideChoice = "";
				if (document.getElementById("radio_editor_right").checked){
					radio_sideChoice = "right";
				}else if (document.getElementById("radio_editor_left").checked){
					radio_sideChoice = "left";
				}

				var select = document.getElementById("select_editor_speaker");
				select_value = select.value;


				if (radio_sideChoice !== ""){
					sm.addNode(NodeCategoryEnum.DEFAULT, value, select_value, radio_sideChoice);
				} else {
				}
				sm.makeGraph(graph, parent);			
			}
		}
		// If a Node is currently selected, the button functionality is to "Update" the selected node
		else {
			var selectedNode = sm.getNodeSelected();
			selectedNode.content = $("#textarea_editor_nodeContent")[0].value;
			selectedNode.metadata.speakerName = $("#select_editor_speaker")[0].value;
			if ($("#radio_editor_left")[0].checked === true){
				selectedNode.metadata.side = "left";
			} else {
				selectedNode.metadata.side = "right";
			}
			
			sm.makeGraph(graph, parent);
		}
	});
	
	// Add onchange callback to the Textarea of the Editor
	$("#textarea_editor_nodeContent").change(function() {
		console.log("DEBUG::textare_editor::onchange -- Updated text");
	});

	// Callback for the "Bold" button of the ActionBar
	$("#button_editorContent_bold").click(function(){
		var textArea = $("#textarea_editor_nodeContent")[0];

		var len = textArea.value.length;
		var start = textArea.selectionStart;
		var end = textArea.selectionEnd;
		var currentSelection = textArea.value.substring(start, end);

		var newText = "<b>" + currentSelection + "</b>"

		textArea.value = textArea.value.substring(0, start)
						+ newText + textArea.value.substring(end, len);
	});

	// Callback for the "Italic" button of the ActionBar
	$("#button_editorContent_italic").click(function(){
		var textArea = $("#textarea_editor_nodeContent")[0];

		var len = textArea.value.length;
		var start = textArea.selectionStart;
		var end = textArea.selectionEnd;
		var currentSelection = textArea.value.substring(start, end);

		var newText = "<i>" + currentSelection + "</i>"

		textArea.value = textArea.value.substring(0, start)
						+ newText + textArea.value.substring(end, len);
	});

		// Callback for the "Underligned" button of the ActionBar
		$("#button_editorContent_underligned").click(function(){
		var textArea = $("#textarea_editor_nodeContent")[0];

		var len = textArea.value.length;
		var start = textArea.selectionStart;
		var end = textArea.selectionEnd;
		var currentSelection = textArea.value.substring(start, end);

		var newText = "<u>" + currentSelection + "</u>"

		textArea.value = textArea.value.substring(0, start)
						+ newText + textArea.value.substring(end, len);
	});

	/** 
	 *	EDITOR TABS 
	 */
	// Add callback functions to the buttons to make them switch tabs

	 // This dict will contain the match betwen the buttons and the associated tabs
	var match_dict = [];

	match_dict["editorContainer_tabsContainer_content"] = "editorContainer_container_tabContent";
	match_dict["editorContainer_tabsContainer_speaker"] = "editorContainer_container_tabSpeaker";
	match_dict["editorContainer_tabsContainer_metadata"] = "editorContainer_container_tabMetadata";
	match_dict["editorContainer_tabsContainer_dev"] = "editorContainer_container_tabDev";

	buttons_list = document.getElementsByClassName("editor_tabs_button");
	for (var i = 0; i < buttons_list.length; i++){
		buttons_list[i].addEventListener("click", function(){

			console.log("in");
			//Set the "active" class to the button that was clicked
			var current = document.getElementsByClassName("editor_tabs_button_active");
			current[0].className = current[0].className.replace(" editor_tabs_button_active", " editor_tabs_button");

			// "this" will be the button that was clicked
			this.className = this.className.replace("editor_tabs_button", " editor_tabs_button_active");
			
			// Display the associated tab
			var targetTab = match_dict[current[0].id];
			tabs_list = document.getElementsByClassName("editorContainer_container_tab");
			for(var i = 0; i < tabs_list.length; i++) {
				tabs_list[i].style.display = "none";
			}
			$("#" + targetTab)[0].style.display = "block";
		});
	}

	// Set the tab "Content" to default and also make its button active
	var button_tab_content = $("#editorContainer_tabsContainer_content")[0];
	button_tab_content.className = button_tab_content.className.replace("editor_tabs_button", "");
	button_tab_content.className += " editor_tabs_button_active";

	$("#editorContainer_container_tabContent")[0].style.display = "block";
	
	// Callback for the "Unload" button of the Speaker tab
	$("#button_editor_unload").click(function(){
		sm.editor.unloadSpeakerFromEditor();
	});

	// Add callback for the "Delete Node" button of the Speaker tab
	$("#button_editor_deleteNode").click(function(){
		sm.deleteNode(sm.currentSelectedNode.id);
	});

	// Callback for the isNodeMetaGlobal_b switch of the Metadata tab
	$("#editorMetadata_isGlobalCheckbox").on("click", function(){
		var value = $(this).prop('checked');
		sm.isNodeMetaGlobal_b = value;
		
		var newMode = null;
		// Set the value for the new Metadata mode
		sm.editor.requestMetadataMode(sm.isNodeMetaGlobal_b);
	});

	// Callback for the "Update" button of the Metadata tab
	$("#editorMetadata_updateButton").on("click", function(){
		//Retrieve the values from the fields
		var l_location = $("#editorMetadata_locationInput")[0].value;
		var l_date = $("#editorMetadata_datepicker")[0].value;

		if (sm.isNodeMetaGlobal_b == true) { // Case: global metadata
			// Update the global SpeechMap metadata
			sm.metadata.location = l_location
			sm.metadata.date = l_date
		} else { // Case: local metadata
			// Get the current selected node
			sm.currentSelectedNode.metadata.location = l_location;
			sm.currentSelectedNode.metadata.date = l_date;
		}
	});
}
 
SpeechMap_Editor.prototype.setTextArea = function(newContent){
	// Get the text area and update it's value
	$("#textarea_editor_nodeContent")[0].value = newContent;
}

SpeechMap_Editor.prototype.clearTextArea = function() {
	// Get the text area html element and remove it's content 
	$("#textarea_editor_nodeContent")[0].value = "";
}

SpeechMap_Editor.prototype.setSpeaker = function(newSpeaker) {
	$("#select_editor_speaker").val(newSpeaker);
	$("#select_editor_speaker").material_select();
}

SpeechMap_Editor.prototype.setSide = function(newSide) {
	if (newSide === "left"){
		$("#radio_editor_left")[0].checked = true;
		$("#radio_editor_right")[0].checked = false;
	} else if (newSide === "right") {
		$("#radio_editor_right")[0].checked = true;
		$("#radio_editor_left")[0].checked = false;
	}
}

SpeechMap_Editor.prototype.addSpeakerInList = function(value, logo, color){
	// Add the new speaker to the list of registered speakers in the SpeakerTab of the editor
	var node = document.createElement("li");
	node.classList.add("collection-item");
	node.classList.add("avatar");

	var logo = document.createElement("img");
	logo.src = "res/default-speaker-logo.png";
	logo.classList.add("circle");

	var span = document.createElement("span");
	span.classList.add("title");
	var textNode = document.createTextNode(value);
	span.appendChild(textNode);

	var colorDiv = document.createElement("div");
	colorDiv.classList.add("speakerList-colorViewer");
	colorDiv.style.background = color;

	node.appendChild(logo);
	node.appendChild(span);
	node.appendChild(colorDiv);

	$("#speakerTab_speakersList")[0].appendChild(node);


	// Add callback to the elements of the list
	$("#speakerTab_speakersList .collection-item").click(function(){
		$("#speakerTab_speakersList .collection-item").each(function(){
			this.style.backgroundColor = "#ffffff";
		});
		this.style.backgroundColor = "#a2a2a2"

		sm.editor.loadSelectedSpeaker(this);
	
	});
}


SpeechMap_Editor.prototype.updateSpeakerInList = function(name, logo, color){

	var speakerList = $("#speakerTab_speakersList")[0].children;

	for (var i = 0; i < speakerList.length; i++){
		if (speakerList[i].children[1].innerHTML == this.selectedSpeakerName) {
			
			// Update the name and the color of the selected speaker
			speakerList[i].children[1].innerHTML = name;
			speakerList[i].children[2].style.backgroundColor = color;
			// Unload the editor
			this.unloadSpeakerFromEditor(null);
		}
	}
}

SpeechMap_Editor.prototype.loadSelectedSpeaker = function(speakerHtmlObject){
	// Children layout:
	// [0] Logo
	// [1] Name
	// [2] Color
	var name = speakerHtmlObject.children[1].innerHTML;
	var color = speakerHtmlObject.children[2].style.backgroundColor;

	this.switchEditMode("EDIT_MODE_UPDATE", name, color);
}


SpeechMap_Editor.prototype.unloadSpeakerFromEditor = function(htmlObject)
{
	this.switchEditMode("EDIT_MODE_ADD", "", "#ffffff");
}
 

SpeechMap_Editor.prototype.switchEditMode = function(newMode, name, color) {
	if (newMode == "EDIT_MODE_UPDATE"){ // Switch the speaker panel to "Edit selected speaker" mode
		
		// Change the icon
		$("#button_editor_newSpeaker i")[0].innerHTML = "save";

		// Make the unload button visible
		$("#button_editor_unload")[0].style.display = "inline-block";

		// Set the class variable to notify that one speaker is selected
		this.selectedSpeakerName = name;
		this.speakerIsSelected = true;
	} else if (newMode == "EDIT_MODE_ADD") { // Switch the Speaker panel to default mode 

		// Revert the icon to "+"
		$("#button_editor_newSpeaker i")[0].innerHTML = "add";
	
		// Make the unload button hidden
		$("#button_editor_unload")[0].style.display = "none";

		this.speakerIsSelected = false;
		this.selectedSpeakerName = "";

		// Remove the visual effect on the list element
		$("#speakerTab_speakersList .collection-item").each(function(){
			this.style.backgroundColor = "#ffffff";
		});
	}
	// Set the values into the fields
	$("#input_editor_newSpeaker")[0].value = name;
	$("#editorSpeaker_colorPicker").colorpicker("setValue", color);
}


SpeechMap_Editor.prototype.updateSelectedSpeaker = function(name, logo, color)
{
	for (var i = 0; i < sm.metadata.speakersList.length; i++){
		if (sm.metadata.speakersList[i].name == this.selectedSpeakerName) {
			sm.metadata.speakersList[i].name = name;
			sm.metadata.speakersList[i].color = color;
			// DEBUG -- Add logo here

			this.updateSpeakerInList(name, logo, color);
		}
	}
}

// Function to load the date / location
SpeechMap_Editor.prototype.loadMetadata = function(location, date) {

	// Update the value in the fields and give the labels the active class
	$("#editorMetadata_locationInput")[0].value = location;
	$("#editorMetadata_locationInput").next()[0].classList.add("active");
	
	$("#editorMetadata_datepicker")[0].value = date;
	$("#editorMetadata_datepicker").next()[0].classList.add("active");

	// Display the update button
	this.showMetadataButtons();
}

SpeechMap_Editor.prototype.unloadMetadata = function() {
	// Clear the fields and hide the buttons
	this.clearMetadataFields();

	// Hide the buttons
	this.hideMetadataButtons();

	// TODO -- Remove the active class for the labels? 
}

SpeechMap_Editor.prototype.clearMetadataFields = function() {
	$("#editorMetadata_locationInput")[0].value = "";
	$("#editorMetadata_datepicker")[0].value = "";
}

SpeechMap_Editor.prototype.showMetadataButtons = function() {
	$("#editorMetadata_updateButton")[0].style.display = "inline-block";
}

SpeechMap_Editor.prototype.hideMetadataButtons = function() {
	$("#editorMetadata_updateButton")[0].style.display = "none";
}

SpeechMap_Editor.prototype.requestMetadataMode = function(newMode_b) {
	var newMode_str = null;
	
	if (newMode_b == true){ 
		newMode_str = "METADATA_MODE_GLOBAL";
	} else {
		newMode_str = "METADATA_MODE_LOCAL";
	}

	this.switchMetadataMode(newMode_str);
}

SpeechMap_Editor.prototype.switchMetadataMode = function(newMode_str) {

	console.log("DEBUG -- Metadata mode switch :" + newMode_str);
	if (newMode_str == "METADATA_MODE_GLOBAL") {
		sm.editor.showMetadataButtons();
		sm.editor.loadMetadata(sm.metadata.location, sm.metadata.date);
	} else if (newMode_str == "METADATA_MODE_LOCAL") {
		sm.editor.clearMetadataFields();
		sm.editor.hideMetadataButtons();
	} else {
		console.log("ERROR -- Unrecognized mode request. Requested value " + newMode);
	}

}


/*************************************************************************************
 *	SpeechMap_GraphController Class 
 *	Contains all the callback functions associated with events on the Graph 
 *  Events could be mouseMove, mouseOver or click etc
 *************************************************************************************/
 
 /**
  * Constructor. Takes no parameters. Will register callback functions for the editor's html elements
  */
 SpeechMap_GraphController = function () {
	console.log("SpeechMap_GraphController constructor");
	
	/* Add mxCellMarker */
	var marker = new mxCellMarker(graph);
	var g_metaShow = false;
	var g_lastCell; // TODO Should probably be renamed into something like g_mouseClick_metaExtension
	var g_mouseMove_onCell_b = false;
	var g_mouveMove_lastNode = null;
	
	var g_mouseClick_vertexExtension_show_b = false; // True is the vertex extension is beeing showm
	var g_mouseClick_vertexExtension = null;
	
	var g_mouseClick_nodeSelected_lastCell = null;

	// Add styles for the "Extend" button 
	var style = new Object();
	style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
	style[mxConstants.STYLE_OPACITY] = 100;
	style[mxConstants.STYLE_FILLCOLOR]= '#4286f4';
	style[mxConstants.STYLE_FONTCOLOR]= '#000000';
	style[mxConstants.STYLE_ROUNDED] = true;
	graph.getStylesheet().putCellStyle('style_extendVertex', style);
	delete style;

	var style = new Object();
	style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
	style[mxConstants.STYLE_OPACITY] = 100;
	style[mxConstants.STYLE_FILLCOLOR]= '#ffffff';
	style[mxConstants.STYLE_FONTCOLOR]= '#000000';
	style[mxConstants.STYLE_ROUNDED] = false;
	graph.getStylesheet().putCellStyle('style_extendedVertex', style);
	delete style;

	
	//TODO Remove the code here and put it in SpeechMap functions (rename sm into this, make the globals g_* into class attributes)
	graph.addMouseListener({
		mouseDown: function(graph, me) {
			// Retrieve the cell where click was made.
			var cell = marker.getCell(me);
			
			// Remove the meta popup when clicking aside it.
			if (g_metaShow === true){
				if (cell !== g_lastCell){
					g_metaShow = false;
					graph.removeCells([g_lastCell]);
				}
			}
			
			// Remove the Vertex Extension when clicking aside of it
			if (g_mouseClick_vertexExtension_show_b)
			{
				if (cell !== g_mouseClick_vertexExtension)
				{
					g_mouseClick_vertexExtension_show_b = null;
					graph.removeCells([g_mouseClick_vertexExtension]);
				}
			}
			// Remove the "node selected" attribute of the SpeechMap when clicking aside of it
			if (g_mouseClick_nodeSelected_lastCell) {
				if (cell != g_mouseClick_nodeSelected_lastCell) {
					g_mouseClick_nodeSelected_lastCell = null;
					sm.unsetNodeSelected();
				}
			}
			
			// Check if the clicked cell is either a content vertex or a meta vertex
			if (cell && cell.isVertex ) {
			
				/* Click on a VertexExtender */
				if (sm.isCellVertexExtender(cell))
				{
				
					if (!g_mouseClick_vertexExtension_show_b)
					{
						g_mouseClick_vertexExtension_show_b = true;
						//console.log("Extending the base vertex");
						
						// Get the Node that is being extended
						var node = sm.getNodeFromVertexExtender(cell);
						if (node)
						{
							// Extend the Vertex based on its content 
							var geometry = cell.getGeometry();
							var style = graph.getCellStyle(node.vertex);
							var fontSize = style[mxConstants.STYLE_FONTSIZE] || mxConstants.DEFAULT_FONTSIZE;
							var lineSize = (geometry.width) / (fontSize * 0.625);
							var estimated_lineNumber = node.content.length / lineSize;


							// Take into consideration the number of "\n" in the input string
							var newline_count = 0;
							var str = node.content;
							for (var position = 0; position < str.length; position++){
								if (str.charAt(position) == '\n'){
									newline_count += 1;
								}
							}
							estimated_lineNumber += newline_count;
							
							// Update the geometry variable to use the geometry from the base vertex
							geometry = node.vertex.getGeometry();
							node.vertex_extension = graph.insertVertex(
									parent, null, 
									node.content, 
									geometry.x, geometry.y, 
									geometry.width, estimated_lineNumber * fontSize + 20,
									"style_extendedVertex;whiteSpace=wrap;overflow=hidden;"
								);
								
							g_mouseClick_vertexExtension = node.vertex_extension;
							
							// Set the selection to the newly created node
							marker.markCell(node.vertex_extension);
							// Unset and clear the textArea from the Editor
							sm.unsetNodeSelected();
							sm.setNodeSelected(node);
							//Load the selected Node content and metadata into the editor
							sm.editor.setTextArea(node.content);
							sm.editor.setSpeaker(node.metadata.speakerName);
							sm.editor.setSide(node.metadata.side);	
							g_mouseClick_nodeSelected_lastCell = cell; /* Save the current cell to know when a click will be outside of it */
						}
					}
						
						// Setup mechanism so that one click outside would remove the extension
				}
				/* Click on a Node */
				else if (sm.isContentVertex(cell)){
					// console.log("Content vertex clicked");

					var node = sm.getMatchingNode(cell);
					sm.setNodeSelected(node);
					g_mouseClick_nodeSelected_lastCell = cell; /* Save the current cell to know when a click will be outside of it */
					
					//Load the selected Node content and metadata into the editor
					sm.editor.setTextArea(node.content);
					sm.editor.setSpeaker(node.metadata.speakerName);
					sm.editor.setSide(node.metadata.side);
					
					/* Click on a Node that could be extended */
					if (graph.isLabelClipped(cell) && sm.isVertexLabelTruncated(cell)){
						console.log("Clicked on a vertex that needs to be extended");
					}
				}
				// Click on the extension of a vertex
				else if (sm.isCellVertexExtension(cell)) {
				
					var node = sm.getNodeFromVertexExtension(cell);

					sm.unsetNodeSelected();
					sm.setNodeSelected(node);
				
					//Load the selected Node content and metadata into the editor
					sm.editor.setTextArea(node.content);
					sm.editor.setSpeaker(node.metadata.speakerName);
					sm.editor.setSide(node.metadata.side);
				}
				/* Click on a MetaVertex */
				else if (sm.isMetaVertex(cell)){
					console.log("Meta vertex clicked");
					if (!g_metaShow){
						g_metaShow = true;
						var geo = cell.getGeometry();
						// TODO Clean the scale factor (use a global or something constant)
						var x_popupCoord = geo.x + (geo.width / 2) - (geo.width * 5 / 2);
						var y_popupCoord = geo.y + (geo.height / 2) - (geo.height * 5 / 2);
						g_lastCell = graph.insertVertex(parent, null, "", x_popupCoord, y_popupCoord, geo.width * 5, geo.height * 5);	
						// TODO Set the current selection to the g_lastCell instead of the cell that was clicked
					}
				}
			}
			
		},
		mouseMove: function(graph, me){
			var cell = marker.getCell(me);
			var mouseMove_onCell_previous_b = g_mouseMove_onCell_b;
		
			// TODO Remove, only used for tracing purposes
			if (cell && sm.isCellVertexExtender(cell))
			{
				//console.log("Cell is a vertex_extender");
			}
			
			if (cell && cell.isVertex())
			{
				if (sm.isContentVertex(cell) && sm.isVertexLabelTruncated(cell))
				{
					var node = sm.getMatchingNode(cell);
					if (node)
					{
						g_mouseMove_onCell_b = true; // We are on a content cell

						// Check to detect when the mouse enters the content cell
						if (!mouseMove_onCell_previous_b) // Previous move, we were not on a content cell 
						{
							var vertexGeo = node.vertex.getGeometry();
							node.vertex_extender = graph.insertVertex(
									parent, null, "Extend",
									vertexGeo.x , 
									vertexGeo.y + vertexGeo.height - 20, 
									vertexGeo.width, 20, 
									"style_extendVertex"
								);
								
							g_mouveMove_lastNode = node;
							//console.log("Addind a vertex_extender cell");
						}
					}
				} else {
					if (!sm.isCellVertexExtender(cell))
					{
						g_mouseMove_onCell_b = false;
					}
				}
			} else {
				g_mouseMove_onCell_b = false;
			}
			
			if (!g_mouseMove_onCell_b && mouseMove_onCell_previous_b)
			{
				graph.removeCells([g_mouveMove_lastNode.vertex_extender]);
				//console.log("Removing the vertex_extender cell");
			}
		},
		mouseUp: function(){}
	});
 }


 SpeechMap_GraphController.prototype.scrollGraph = function(newValue){
	console.log("DEBUG -- Scrolling fix");
	var graphDiv = document.getElementById("graphContainer");
	console.log(graphDiv);
	graphDiv.scrollTop = newValue;
 }
 
/*************************************************************************************
 *	SpeechMap_Renderer Class 
 *  Handles the rendering of the map in the graph container
 *************************************************************************************/
 
/**
 * Constructor. Defines constants and styles used during the rendering.
 */
SpeechMap_Renderer = function () {
	console.log("SpeechMap_Renderer constructor");
	
	/* CONSTANTS (initialized with default values) */
	this.RENDER_X_OFFSET = 400;
	this.RENDER_TREE_GAP = 5;

	this.RENDER_VERTEX_MIN_HEIGHT = 4 * 11 + 10 + 10;
	this.RENDER_VERTEX_WIDTH = 150;
	
	this.RENDER_META_SIZE = 30;
	this.RENDER_META_GAP = this.RENDER_VERTEX_MIN_HEIGHT;
	this.RENDER_META_GAP_SAMESPEAKER = this.RENDER_VERTEX_MIN_HEIGHT;
	this.RENDER_META_GAP_CHANGESPEAKER = this.RENDER_VERTEX_MIN_HEIGHT - 25;

	this.RENDER_META_VERTICAL_OFFSET = 15;
	
		/* Add styles */
	var style = new Object();
	style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
	style[mxConstants.STYLE_OPACITY] = 100;
	style[mxConstants.STYLE_FILLCOLOR]= '#FFFFFF';
	style[mxConstants.STYLE_FONTCOLOR]= '#000000';
	style[mxConstants.STYLE_SPACING]= 5;
	style[mxConstants.STYLE_ROUNDED] = false;
	graph.getStylesheet().putCellStyle('style_content_default', style);
	delete style;

	var style = new Object();
	style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
	style[mxConstants.STYLE_OPACITY] = 100;
	style[mxConstants.STYLE_FILLCOLOR]= '#FFFFFF';
	style[mxConstants.STYLE_FONTCOLOR]= '#000000';
	style[mxConstants.STYLE_SPACING]= 5;
	style[mxConstants.STYLE_ROUNDED] = true;
	style[mxConstants.STYLE_STROKECOLOR] = "none";
	graph.getStylesheet().putCellStyle('style_content_speaker_1', style);
	delete style;
	
	var style = new Object();
	style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
	style[mxConstants.STYLE_OPACITY] = 100;
	style[mxConstants.STYLE_FILLCOLOR]= '#FFFFFF';
	style[mxConstants.STYLE_FONTCOLOR]= '#000000';
	style[mxConstants.STYLE_SPACING]= 5;
	style[mxConstants.STYLE_ROUNDED] = true;
	style[mxConstants.STYLE_STROKECOLOR] = "none";
	graph.getStylesheet().putCellStyle('style_content_speaker_2', style);
	delete style;
		
	var style = new Object();
	style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_IMAGE;
	style[mxConstants.STYLE_OPACITY] = 100;
	style[mxConstants.STYLE_FILLCOLOR]= '#4CAF50';
	style[mxConstants.STYLE_STROKECOLOR] = "none";
	style[mxConstants.STYLE_IMAGE] = 'res/default-speaker-logo.png';
	style[mxConstants.STYLE_IMAGE_WIDTH] = 30;
	style[mxConstants.STYLE_IMAGE_HEIGHT] = 30;
	style[mxConstants.STYLE_IMAGE_ASPECT] = 1;
	style[mxConstants.STYLE_IMAGE_BACKGROUND] = "#ffffff";
	graph.getStylesheet().putCellStyle('style_meta_speaker_1', style);
	delete style;

	var style = new Object();
	style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_IMAGE;
	style[mxConstants.STYLE_OPACITY] = 100;
	style[mxConstants.STYLE_FILLCOLOR]= '#4CAF50';
	style[mxConstants.STYLE_STROKECOLOR] = "none";
	style[mxConstants.STYLE_IMAGE] = 'res/default-speaker-logo.png';
	style[mxConstants.STYLE_IMAGE_WIDTH] = 30;
	style[mxConstants.STYLE_IMAGE_HEIGHT] = 30;
	style[mxConstants.STYLE_IMAGE_ASPECT] = 1;
	style[mxConstants.STYLE_IMAGE_BACKGROUND] = "#ffffff";
	graph.getStylesheet().putCellStyle('style_meta_speaker_2', style);
	delete style;
	
	var style = new Object();
	style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
	style[mxConstants.STYLE_OPACITY] = 100;
	style[mxConstants.STYLE_FILLCOLOR]= '#FFFFFF';
	style[mxConstants.STYLE_FONTCOLOR]= '#000000';
	style[mxConstants.STYLE_ROUNDED] = false;
	style[mxConstants.STYLE_STROKECOLOR] = "none";
	graph.getStylesheet().putCellStyle('style_meta_start', style);
	delete style;
	
	var style = new Object();
	style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;
	style[mxConstants.STYLE_OPACITY] = 100;
	style[mxConstants.STYLE_FILLCOLOR]= '#FFFFFF';
	style[mxConstants.STYLE_FONTCOLOR]= '#000000';
	style[mxConstants.STYLE_ROUNDED] = false;
	style[mxConstants.STYLE_STROKECOLOR] = "none";
	graph.getStylesheet().putCellStyle('style_meta_end', style);
	delete style;

	var style = new Object();
	style[mxConstants.STYLE_OPACITY] = 25;
	graph.getStylesheet().putCellStyle("style_edge", style);
	delete style;
}
 
SpeechMap_Renderer.prototype.render = function(graph, parent, nodesList, metadata) {
	console.log("Inside the render function");
	
	this.RENDER_VERTEX_WIDTH = (graph.container.offsetWidth / 10) *3;
	this.RENDER_X_OFFSET = (graph.container.offsetWidth / 2);
	var g_y_metaCoord = 0;

	
	// Clear the graph
	this.clearMap(graph);

	// Make the graph automatically resize the container and add a border
	graph.resizeContainer = false;
	graph.setAutoSizeCells(true);
	graph.setBorder(graph.container.offsetWidth / 10 / 2); /* Usefull at the bottom of the graph */
	
	graph.setHtmlLabels(true);


	//Adds cells to the model in a single step
	graph.getModel().beginUpdate();
	try {	
		for (var i in nodesList){

			var node = nodesList[i];

			// Add bigger gap for start and end nodes
			if (parseInt(i) == 1){
				g_y_metaCoord += 50;
			} else if(parseInt(i) == nodesList.length-1){
				g_y_metaCoord += 100;
			}
			
			// Add the vertex
			if(node.content){

				var color = sm.getColorFromSpeakerName(node.metadata.speakerName);

				var y_metaCoord = 10 + i*(this.RENDER_META_SIZE + this.RENDER_META_GAP);
				if (parseInt(i) > 1 && i < nodesList.length-2 && nodesList[parseInt(i)-1].metadata.speakerName != node.metadata.speakerName)
				{
					// There is a speaker change, make a bigger gap
					g_y_metaCoord += 10 + (this.RENDER_META_SIZE + this.RENDER_META_GAP);
				} else {
					g_y_metaCoord += 10 + this.RENDER_VERTEX_MIN_HEIGHT;
				}
				var y_vertexCoord = g_y_metaCoord - (this.RENDER_VERTEX_MIN_HEIGHT / 2)+ (this.RENDER_META_SIZE / 2);
				
				// node.getSide should always be different from null for a content node
				var nodeSide = node.getSide();
				
				/* Add a node to the appropriate side of the map */
				if (nodeSide === "right"){
					node.vertex = graph.insertVertex(
								parent, null, node.content, this.RENDER_X_OFFSET + this.RENDER_TREE_GAP + this.RENDER_META_SIZE, y_vertexCoord, 80, 30, 
								"style_content_speaker_1;whiteSpace=wrap;overflow=hidden;fillColor=" + color
							);

						// Only add Meta node if the next node is a different speaker OR if is is the last node
						if (i < nodesList.length-2 && nodesList[parseInt(i)+1].metadata.speakerName != node.metadata.speakerName || 
							parseInt(i) == nodesList.length-2 ){
							/* Then the metadata vertex linked to the tree (timeline) */
							node.vertex_treeNode = graph.insertVertex(
									parent, null, "", this.RENDER_X_OFFSET, g_y_metaCoord + this.RENDER_META_VERTICAL_OFFSET, 30, 30,
									"style_meta_speaker_1"
								);
						}
				} else if (nodeSide === "left"){
					node.vertex = graph.insertVertex(
								parent, null, node.content,  this.RENDER_X_OFFSET - this.RENDER_TREE_GAP - this.RENDER_VERTEX_WIDTH, y_vertexCoord, 80, 30,
								"style_content_speaker_2;whiteSpace=wrap;overflow=hidden;fillColor=" + color
							);
							
						// Only add Meta node if the next node is a different speaker  OR if is is the last node (nodesList.length-2 to take into account the end node)
						if (i < nodesList.length-2 && nodesList[parseInt(i)+1].metadata.speakerName != node.metadata.speakerName || 
							parseInt(i) == nodesList.length-2 ){
							/* Then the metadata vertex linked to the tree (timeline) */
							node.vertex_treeNode = graph.insertVertex(
									parent, null, "", this.RENDER_X_OFFSET, g_y_metaCoord + this.RENDER_META_VERTICAL_OFFSET, 30, 30,
									"style_meta_speaker_1"
								);
						}
				}
				
			}else{
				if (node.category === NodeCategoryEnum.START){
					node.vertex = graph.insertVertex(parent, null, "START", this.RENDER_X_OFFSET - 35, g_y_metaCoord, 100, 30, "style_meta_start");
				}else if( node.category === NodeCategoryEnum.END){
					node.vertex = graph.insertVertex(parent, null, "END", this.RENDER_X_OFFSET - 35, g_y_metaCoord, 100, 30, "style_meta_end");
				}
			}
		
			
			/* Update the cells height and location (for the left side cells) */
			if ( i != 0 && (i != nodesList.length - 1)){
				graph.updateCellSize(node.vertex);
				var geometry = node.vertex.getGeometry();
				geometry.height = this.RENDER_VERTEX_MIN_HEIGHT;
				geometry.width = this.RENDER_VERTEX_WIDTH;
				
				// TODO The 5 below should be made a constant (max number of lines in a vertex)
				var style = graph.getCellStyle(node.vertex);
				var fontSize = style[mxConstants.STYLE_FONTSIZE] || mxConstants.DEFAULT_FONTSIZE;
				var max = geometry.width * 5 / (fontSize * 0.625);

				if (max < node.vertex.value.length)
				{
					node.isLabelTruncated = true;
					node.vertex.value = node.vertex.value.substring(0,max) + "...";
				} else {
					// The cell content's does not need to be truncated
				}
			}
		}
	}
	finally
	{
		// Updates the display
		graph.fit();
		graph.getModel().endUpdate();
	}
}

SpeechMap_Renderer.prototype.clearMap = function(graph){
	graph.getModel().beginUpdate();
	graph.removeCells(graph.getModel().getChildVertices(parent));
	graph.getModel().endUpdate();
}

/*************************************************************************************
 *	SpeechMapInitializer Class 
 *	Handles the intial overlay and can return the xmlDoc to be used to create a SpeechMap
 *  Also handles the event callbacks for the overlay HTML elements
 *************************************************************************************/
 
/**
 * Constructor.  Will register callback functions for the overlay's html elements and create the xmlDoc based on the user choices
 */
SpeechMapInitializer = function (initCompleteCallbackFunction) {
	/** OVERLAY RELATED JAVASCRIPT */
	
	this.currentSelection = "";
	this.sm = sm;
	this.initCompleteCallbackFunction = initCompleteCallbackFunction
	
	// Simulate a click on the "show overlay" button
	$("#a_showOverlay")[0].click();

	
	// Callback when clicking on the "New Map" div
	$("#div_overlay_main_newMap").click(function(){
		console.log("New Map selected");
		this.currentSelection = "NEW_MAP";
		
		//Set the effects for the current selection and clean it for the other choice
		$("#div_overlay_main_newMap")[0].style.boxShadow = "0 10px 20px #941818, 0 6px 6px #941818";
		$("#div_overlay_main_loadMap")[0].style.boxShadow = "";
	}.bind(this));

	// Callback when clicking on the "Load Map" div
	$("#div_overlay_main_loadMap").click(function(){
		console.log("Load Map selected");
		this.currentSelection = "LOAD_MAP";
		
		//Set the effects for the current selection and clean it for the other choice
		$("#div_overlay_main_loadMap")[0].style.boxShadow = "0 10px 20px #941818, 0 6px 6px #941818";
		$("#div_overlay_main_newMap")[0].style.boxShadow = "";
	}.bind(this));
	
	// Callback for the "Confirm" button of the overlay
	$("#button_overlay_bottom_confirm").click(function(){
		console.log("Clicked on the confirm button");
		
		// If NEW_MAP, then create the default map
		if (this.currentSelection === "NEW_MAP") {
			this.sm = new SpeechMap(null);
			this.initCompleteCallbackFunction();
			//console.log(this.sm.serializeToConsole());
			//this.sm.makeGraph(graph, parent);
		}
		// Else if LOAD_MAP, get a file from the user, make a XMLDocument from it and create the according map
		else if (this.currentSelection === "LOAD_MAP") {
			// Nested events below
			var button_loadMap = $("#button_overlay_loadMap");
			
			// 1 - Function called when the "LoadMap" button has been clicked (click is simulated below, button is not displayed)
			button_loadMap.change(function(){
				// 3 - Retrieve the file that was uploaded by the user and instanciate a FileReader object				
				var file = $("#button_overlay_loadMap")[0].files[0];
				var fileReader = new FileReader();
				// 4 - Function called once reading the file is complete
				fileReader.onload = function(fileContent){
					// 6 - Parse the file that was uploaded a make a SpeechMap from it
					// TODO Add checks to assert that the uploaded document is indeed an xml file
					var parser = new DOMParser();
					var xmlDoc = parser.parseFromString(fileReader.result, "text/xml");
					this.sm = new SpeechMap(xmlDoc);
					this.initCompleteCallbackFunction();
					//console.log(this.sm.serializeToConsole());
					//this.sm.makeGraph(graph, parent);
				}.bind(this);
				// 5 - Start reading the file that was uploaded
				fileReader.readAsText(file);
			}.bind(this));
			
			// 2 - Simulate a click on the "Load Map" button for the user to pick a file from his filesystem
			button_loadMap[0].click(); 
		}			
		// Hide the overlay
		document.location = "#";
	}.bind(this));
}

SpeechMapInitializer.prototype.getSM = function() {
	return this.sm;
}
</script>


<script>

var graph = null;
var parent = null;
var sm = null;
var smi = null;

/** Convenient utility function 
$ = function(id) {
			return document.getElementById(id);
}
*/
generateId = function() {
	var d = new Date().getTime();
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
    });
    return uuid;
}

/** Main function executed once the page is loaded */
function main(container){

	var loremString = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris rutrum imperdiet lorem, a eleifend tellus efficitur non. Suspendisse rutrum molestie auctor. Proin eget sem pellentesque, posuere ligula vestibulum, auctor ipsum. Nullam eu elementum tellus. Sed ullamcorper in turpis ut porta. Vivamus tincidunt ex vitae velit pretium tempor. Duis commodo quis lorem pharetra ornare. Cras nunc felis, maximus sed est at, mollis porttitor enim. Aliquam interdum imperdiet rutrum. Nulla gravida consectetur libero elementum auctor. Integer id vestibulum neque, ut feugiat dolor. Maecenas blandit lacus ut euismod consectetur. Ut ac vestibulum leo. Donec ac lacus sed nunc facilisis consequat in eu risus. Nullam tempor sed nunc ut aliquet. Vivamus a pulvinar just";

	/* Callback function that will be called once the overlay/init is complete. This function will retrieve the SpeechMap instance created by the SMI instance */
	var smi_initCompleteCallback = function() {
		sm = smi.getSM();
		sm.executePostInitSequence();
		sm.makeGraph(graph, parent);
	};
	smi = new SpeechMapInitializer(smi_initCompleteCallback);

	// Add callback to the button
	$("#button_addNode_HerrA").click(function(){
		console.log("Button Click");
		
		sm.addNode(NodeCategoryEnum.DEFAULT, loremString, "Herr A", "right");
		sm.makeGraph(graph, parent);
	});
	
	// Add callback to the button
	$("#button_addNode_HerrB").click(function(){
		console.log("Button Click");
		
		sm.addNode(NodeCategoryEnum.DEFAULT, loremString, "Herr B", "left");
		sm.makeGraph(graph, parent);
	});
	
	// Add callback to the "Clear" button
	$("#button_clear").click(function(){
		console.log("Button Clear Click");
		
		sm.clearMap(graph,parent);
	});
	
	// Add callback to the "XML String" button
	$("#button_xmlString").click(function(){
		console.log("Button XML String");
		
		sm.serializeToXML();
	});


	/*******************************
	 * Init of the mxGraph for the SpeechMap
	 *******************************/
	// Init the mxGraph
	graph = new mxGraph(container);
	
	// Gets the default parent for inserting new cells. This
	// is normally the first child of the root (ie. layer 0).
	parent = graph.getDefaultParent();

	
};
$(document).ready(function () {
	$('select').material_select();



	$('.datepicker').pickadate({
		container: "body"
	});

    $('#editorSpeaker_colorPicker').colorpicker({
      component: '.btn'
    });
			

	main(document.getElementById('graphContainer'))
});
</script>
<script type="text/javascript" src="js/materialize.min.js"></script>
<script type="text/javascript" src="js/materialize-colorpicker.min.js"></script>

</body>
</html> 